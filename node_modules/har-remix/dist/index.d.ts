/// <reference types="node" />
import * as http from "http";
/**
 * Delegate for archive server
 */
export interface ServerDelegate {
    /**
     * Create a key for the request that will be used to match
     * the server request to the archived response.
     *
     * Return undefined if you do not want to serve this request.
     */
    keyForArchiveEntry(entry: HAR.Entry): string | undefined;
    /**
     * Create a key from the request to match against the archived requests.
     */
    keyForServerRequest(req: http.IncomingMessage): string | undefined;
    /**
     * Allows simple text content to be transformed.
     */
    textFor?(entry: HAR.Entry, key: string, text: string): string;
    /**
     * By default, only 200 requests are responsed to.
     *
     * If you return a key for a non 200 request this method is called.
     */
    responseFor?(entry: HAR.Entry, key: string): Response | undefined;
    /**
     * Finalize the response before adding it, by default no headers are copied.
     *
     * This hook allows you to copy headers or alter response or return a new response before added.
     */
    finalizeResponse?(entry: HAR.Entry, key: string, response: Response): Response;
    /**
     * Called if no response found. Will 404 if no headers sent.
     *
     * Allows fallback.
     */
    missingResponse?(request: http.IncomingMessage, response: http.ServerResponse): any;
}
export interface Response {
    statusCode: number;
    headers: MapLike<string>;
    body: Buffer;
    next: Response | undefined;
}
export default class ArchiveServer {
    private delegate;
    private responses;
    constructor(delegate: ServerDelegate);
    loadArchive(path: string): void;
    addArchive(har: HAR): void;
    addArchiveEntries(entries: HAR.Entry[]): void;
    addArchiveEntry(entry: HAR.Entry): void;
    addResponse(key: string, response: Response): void;
    responseFor(key: string): Response | undefined;
    handle(request: http.IncomingMessage, response: http.ServerResponse): void;
    createServer(): http.Server;
}
export interface MapLike<T> {
    [key: string]: T | undefined;
}
export interface HAR {
    log: HAR.Log;
}
export declare namespace HAR {
    interface Log {
        version: string;
        entries: Entry[];
    }
    interface Entry {
        request: Request;
        response: Response;
    }
    interface Request {
        method: string;
        url: string;
        httpVersion: string;
        cookies: {
            name: string;
            value: string;
            expires: string;
            httpOnly: boolean;
            secure: boolean;
        }[];
        headers: {
            name: string;
            value: string;
        }[];
        queryString: {
            name: string;
            value: string;
        }[];
        postData?: {
            mimeType: string;
            text: string;
            params?: {
                name: string;
                value?: string;
                fileName?: string;
                contentType?: string;
            }[];
        };
        headersSize: number;
        bodySize: number;
    }
    interface Response {
        status: number;
        statusText: string;
        httpVersion: string;
        cookies: {
            name: string;
            value: string;
            path: string;
            domain: string;
            expires: string;
            httpOnly: boolean;
            secure: boolean;
        }[];
        headers: {
            name: string;
            value: string;
        }[];
        content: Content;
        redirectURL: string;
        headersSize: number;
        bodySize: number;
    }
    interface Content {
        size: number;
        compression?: number;
        mimeType: string;
        text: string;
        encoding?: string;
    }
}
